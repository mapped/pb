// ******************************************************************************************************
// Copyright 2022 Mapped Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ******************************************************************************************************
syntax = "proto3";

package mapped.cloud.types;

option cc_enable_arenas = true;
option java_multiple_files = true;
option java_package = "com.mapped.cloud.types";
option csharp_namespace = "Mapped.Cloud.Types";
option go_package = "go.mapped.dev/pb/cloud/types;types";

import "google/protobuf/descriptor.proto";
import "google/protobuf/timestamp.proto";
import "mapped/cloud/types/typed_value.proto";

// Filters consist of four components:
// 1. `Filters` are the message types that exist in ListRequest messages and
//    are passed to GTM to generate BSON. Filters must only contain:
//     - FilterExpression fields (must NOT be `repeated`)
//     - nested_filter fields (must NOT be `repeated`)
//     - `and`/`or`/`not` - `repeated` recursive fields
//    field IDs can be whatever makes sense to you. An example Filter is:
//    ```proto
//    message MyFilter {
//        StringFilterExpression my_field = 1;
//        Int32FilterExpression my_value  = 2 [(mapped.cloud.types.filter_path) = "my_root_type.my_value"];
//        MyTypeFilter my_type = 3;
//        
//        repeated MyFilter and = 10;
//        repeated MyFilter or = 10;
//        repeated MyFilter not = 10;
//    }
//    ```
//
// 2. `FilterExpressions` are scalar type expressions that contain operations
//    as fields. In most cases, only one operation field can be set. Note that
//    we don't use `oneof` so that GTM can reject when multiple fields are set.
//    That said, some types do allow multiple fields to be set and are decorated
//    with the `allow_multi` option. This is useful for range checks, like an
//    Int32 value being (>=10 && <20) without forcing a recursion to an AND.
//    There are several FilterExpressions below. New ones should be defined with
//    great care, and tested thoroughly.
//
// 3. `nested_filter` is an option that can be specified on a `Filter` for a
//    custom non-scalar type. Only one level of nesting is allowed, and these
//    nested filters must consist of all `FilterExpression` fields (that is,
//    no `and`/`or`/`not` and no `nested_filter` fields). An example filter is:
//    ```proto
//    message MyTypeFilter {
//    	option (nested_filter) = true;
//
//    	IDFilterExpression place_id = 1;
//      TimestampFilterExpression created = 2;
//    }
//    ```
// 4. `filter_elem_match` is an option that can be specified on a `Filter` for a
//     custom non-scalar type that contains fields of objects found in arrays.
//     Each of the fields in the filter must be FilterExpressions, and will be
//     translated into an `$elemMatch` query. An example is:
//     ```proto
//     message MyElemMatch {
//         option (mapped.cloud.types.filter_elem_match) = true;    // This is the key part.
//     
//         mapped.cloud.types.StringFilterExpression field_a = 1;
//         mapped.cloud.types.StringFilterExpression field_b = 2 [(mapped.cloud.types.filter_path) = "b"]; // Can still use filter_path
//     }
//     ```
//     Then this:
//     ```go
//     filter := &my.api.MyFilter{
//         TestId: &types.IDFilterExpression{Eq: "xyz"},
//         TestElemMatch: &my.api.MyElemMatch{
//             FieldA: &types.StringFilterExpression{Eq: "aVal"},
//             FieldB: &types.StringFilterExpression{Ne: "bVal"},
//         },
//     }
//     ```
//     Will producec:
//     ```json
//     {
//       "$and": [
//         { "testId": "xyz" },
//         { "test": { "$elemMatch": { "fieldA": "aVal", "b": { "$ne": "bVal" } } } }
//       ]
//     }
//     ```

//
// FilterExpressions
//
message IDFilterExpression {
    option (filter_expression) = true;

    string eq          = 1 [(op) = OP_EQ];
    repeated string in = 2 [(op) = OP_IN];
}

message StringFilterExpression {
    option (filter_expression) = true;

    string eq          = 1 [(op) = OP_EQ];
    string contains    = 2 [(op) = OP_CONTAINS];
    repeated string in = 3 [(op) = OP_IN];
    string ne          = 4 [(op) = OP_NE];
    string re          = 5 [(op) = OP_REGEX];
    string eq_case_insensitive          = 6 [(op) = OP_EQUALS_CASE_INSENSITIVE];
    string contains_case_insensitive    = 7 [(op) = OP_CONTAINS_CASE_INSENSITIVE];
}

message StringMapStringFilterExpression {
    string                  key = 1;
    StringFilterExpression  value = 2;

    // AST
    repeated StringMapStringFilterExpression and = 100;
    repeated StringMapStringFilterExpression or = 101;
    repeated StringMapStringFilterExpression not = 102;
}

message StringMapInt64FilterExpression {
    string                  key = 1;
    Int64FilterExpression   value = 2; // TODO: Should this be eq instead?

    // AST
    repeated StringMapInt64FilterExpression and = 100;
    repeated StringMapInt64FilterExpression or = 101;
    repeated StringMapInt64FilterExpression not = 102;
}

message BoolFilterExpression {
    option (filter_expression) = true;

    bool eq = 1 [(op) = OP_EQ];

    bool is_defined = 10; // This is to distinguish explicitly defined value from its default value. The filter is not effective unless _is_defined == true
}

message FloatFilterExpression {
    option (filter_expression) = true;
    option (allow_multi) = true;

    float eq          = 1 [(op) = OP_EQ];
    float gt          = 2 [(op) = OP_GT];
    float gte         = 3 [(op) = OP_GTE];
    float lt          = 4 [(op) = OP_LT];
    float lte         = 5 [(op) = OP_LTE];
    repeated float in = 6 [(op) = OP_IN];
}

message Int32FilterExpression {
    option (filter_expression) = true;
    option (allow_multi) = true;

    int32 eq          = 1 [(op) = OP_EQ];
    int32 gt          = 2 [(op) = OP_GT];
    int32 gte         = 3 [(op) = OP_GTE];
    int32 lt          = 4 [(op) = OP_LT];
    int32 lte         = 5 [(op) = OP_LTE];
    repeated int32 in = 6 [(op) = OP_IN];
}
message Int64FilterExpression {
    option (filter_expression) = true;
    option (allow_multi) = true;

    int64 eq          = 1 [(op) = OP_EQ];
    int64 gt          = 2 [(op) = OP_GT];
    int64 gte         = 3 [(op) = OP_GTE];
    int64 lt          = 4 [(op) = OP_LT];
    int64 lte         = 5 [(op) = OP_LTE];
    repeated int64 in = 6 [(op) = OP_IN];
}
message UInt32FilterExpression {
    option (filter_expression) = true;
    option (allow_multi) = true;

    uint32 eq          = 1 [(op) = OP_EQ];
    uint32 gt          = 2 [(op) = OP_GT];
    uint32 gte         = 3 [(op) = OP_GTE];
    uint32 lt          = 4 [(op) = OP_LT];
    uint32 lte         = 5 [(op) = OP_LTE];
    repeated uint32 in = 6 [(op) = OP_IN];
}
message UInt64FilterExpression {
    option (filter_expression) = true;
    option (allow_multi) = true;

    uint64 eq          = 1 [(op) = OP_EQ];
    uint64 gt          = 2 [(op) = OP_GT];
    uint64 gte         = 3 [(op) = OP_GTE];
    uint64 lt          = 4 [(op) = OP_LT];
    uint64 lte         = 5 [(op) = OP_LTE];
    repeated uint64 in = 6 [(op) = OP_IN];
}
message StringArrayFilterExpression {
    option (filter_expression) = true;

    string eq           = 1 [(op) = OP_EQ];
    repeated string in  = 2 [(op) = OP_IN];
    string ne           = 3 [(op) = OP_NE];
    repeated string nin = 4 [(op) = OP_NIN];
}

message TimestampFilterExpression {
    option (filter_expression) = true;
    option (allow_multi) = true;

    google.protobuf.Timestamp eq     = 1 [(op) = OP_EQ];
    google.protobuf.Timestamp gt     = 2 [(op) = OP_GT];
    google.protobuf.Timestamp gte    = 3 [(op) = OP_GTE];
    google.protobuf.Timestamp lt     = 4 [(op) = OP_LT];
    google.protobuf.Timestamp lte    = 5 [(op) = OP_LTE];
}

message TimestampRangeFilterExpression {
    option (filter_expression) = true;

    google.protobuf.Timestamp gte    = 3 [(op) = OP_GTE];
    google.protobuf.Timestamp lte    = 5 [(op) = OP_LTE];
}

//
// Extensions used in the creation of FilterExpressions and Filters
//
extend google.protobuf.FieldOptions {
    // For Filters, this allows a json dot separated path to be specified for the field
    // location in MongoDB or other document stores. It is optional, and only needed if
    // the filter.value.xyz field being referenced is nested in the document store.
    //
    // For example:
    // ```
    // string person_name = 1 [(filter_path) = "my.value.person_name"];
    // ```
    // Note that "person_name" at the end of that path is in Protobuf snake_case, not
    // JSON lowerCamelCase. GTM will give it the proper casing when generating BSON.
    string filter_path = 75000;

    // For FilterExpressions, this is the operation to be used in the creation of BSON
    Operator op = 75001;
}

extend google.protobuf.MessageOptions {
    // Indicates this message is a nested Filter for a custom type (see notes at the top)
    bool nested_filter = 75000;

    // Indicates this message is a FilterExpression
    bool filter_expression = 75100;

    // For FilterExpressions, allows multiple values to be set which will be AND'd together
    // default is false
    bool allow_multi = 75101;

    // Indicates this message's fields should be translated into an $elemMatch query.
    bool filter_elem_match = 75102;
}

enum Operator {
    OPERATOR_UNSPECIFIED = 0;

    // Existance
    OP_EXISTS = 1;      // bool value (true=exists, false=does not exist)

    // Numeric expressions
    OP_EQ = 10;     // == 
    OP_NE = 11;     // !=
    OP_GT = 12;     // >
    OP_GTE = 13;    // >=
    OP_LT = 14;     // <
    OP_LTE = 15;    // <=

    OP_EQ_ELEM_MATCH = 16; // Matches if the stored array field contains an element that matches the provided query value (used for arrays of objects)
    OP_NE_ELEM_MATCH = 17; // Matches if the stored array field does not contain an element that matches the provided query value (used for arrays of objects)
    
    // String expressions
    OP_EQUALS       = 20;
    OP_CONTAINS     = 21;
    OP_REGEX        = 22;      // Regex - regex in query value provided used on stored field (/pattern/{opts} or 'pattern' format)
    OP_INVREGEX     = 23;      // Inverted regex - regex in stored field used on query value provided
    OP_EQUALS_CASE_INSENSITIVE      = 24; // Case insensitive equals
    OP_CONTAINS_CASE_INSENSITIVE    = 25; // Case insensitive contains


    // Array expressions
    OP_SIZE = 31;       // Matches if the stored array field is the size specified in the query value
    OP_ALL = 32;        // Matches stored arrays that contain all elements specified in the query value array
    OP_IN = 33;         // Check if a stored scalar field is ANY of the values in the provided query value array
    OP_NIN = 34;        // Check if a stored scalar field is NONE of the values in the provided query value array

    // TODO: Geospatial
}

//
// DEPRECATED: Stop using this. Switch to the new filter format...
//
message Filter {
    option deprecated = true;

    map<string, OpValue> field_ops = 1;

    repeated Filter and = 10;
    repeated Filter or = 11;
    repeated Filter not = 12;
}

message OpValue {
    Operator op = 1;
    mapped.cloud.types.TypedValue value = 2;
}
